# 執行緒

​	執行緒是作業系統中一個輕量級的執行單位，是Process的一部分。每個Process可以包含一個或多個執行緒，這些執行緒雖然共想該Process的資源，但它們都有自己的執行堆疊以及程式計數器。

### 執行緒主要特點

1. **輕量級**：相比於進程，執行緒的創建和管理開銷較小，因為執行緒之間共享大部分資源。
2. **並行性**：多個執行緒可以同時執行，這使得應用程式能夠更有效地利用多核處理器，提升性能。
3. **共享資源**：執行緒之間可以共享數據和資源，但這也可能導致資料競爭和同步問題，因此需要適當的同步機制（例如互斥鎖）來保護共享資源。
4. **上下文切換**(ch 3.2-3)：執行緒之間的上下文切換比進程之間的切換要快，因為執行緒共享進程的上下文，切換時只需要保存和恢復執行緒的狀態。

### 執行緒與CPU之間的關係

1. **執行單位**：執行緒是CPU執行的基本單位。當CPU執行程序時，實際上是在執行執行緒。每個執行緒都有自己的執行堆疊和程式計數器，使得多個執行緒可以獨立運行。
2. **並行處理**：現代CPU通常具備多核心設計，這意味著能夠同時執行多個執行緒。每個核心可以獨立執行一個或多個執行緒，這樣可以顯著提高程序的執行效率。當有多個執行緒可以同時運行時，程序的反應速度和處理性能都會提高。
3. **時間分配**：在單核心CPU中，雖然無法真正實現並行執行，但透過快速的上下文切換，CPU可以在多個執行緒之間分配時間，讓每個執行緒在短時間內獲得執行的機會。這種情況下，CPU將根據排程算法（如輪詢、優先級等）來決定哪個執行緒獲得CPU的控制權。
4. **資源管理**：執行緒共享同一進程中的資源，這使得執行緒之間可以快速通訊，但也帶來了競爭條件和同步問題。CPU負責執行這些執行緒的任務時，必須適當管理執行緒之間的資源訪問，以避免衝突和不一致的狀態。



## 多核心系統的程式設計的五大挑戰

### 1. 辨識任務（Identifying Tasks）

- **意義**：在多核心系統中，首先需要識別出哪些計算任務可以被並行處理。
- **說明**：這個步驟涉及到分析你的程式或應用程式的整體架構，找出可以拆分為獨立任務的部分。這些任務應該是相對獨立的，不會互相影響。例如，如果你在處理一個大數據集，可能可以將數據分成多個部分，分別進行處理，最後再將結果合併。

### 2. 平衡（Load Balancing）

- **意義**：當多個核心同時工作時，重要的是要確保所有核心的工作量大致相同，以提高整體性能。
- **說明**：這意味著在分配任務時，應該盡量避免讓某些核心忙碌而其他核心閒置的情況。比如，假設有四個核心，你不應該把所有的任務都放在一個核心上，這樣會導致性能瓶頸。平衡的關鍵是動態調整任務的分配，以使所有核心都能充分運用。

### 3. 資料分割（Data Partitioning）

- **意義**：在進行計算時，如何將數據分成小塊，使每個核心能獨立處理。
- **說明**：資料分割涉及將數據集分為若干部分，並將這些部分分配給不同的執行緒或核心進行處理。例如，處理圖像時，可以將圖像切割成多個區域，分別交給不同的核心來處理，這樣可以提高處理效率。

### 4. 資料相依（Data Dependency）

- **意義**：這是指任務或資料之間的依賴關係，會影響執行的順序。
- **說明**：在多核心系統中，若一個任務的輸出需要作為另一個任務的輸入，那麼這兩個任務之間就存在資料相依的關係。必須小心管理這種依賴，以避免執行順序錯誤導致的錯誤。例如，如果任務 A 需要任務 B 的結果才能運行，就不能讓這兩個任務同時執行，必須先執行任務 B。

### 5. 測試與偵錯（Testing and Debugging）

- **意義**：在多執行緒或多核心系統中，錯誤的發生和追蹤變得更加困難。
- **說明**：由於多個執行緒同時運行，可能會出現競爭條件（兩個或更多執行緒同時訪問同一資料），死鎖（兩個執行緒互相等待對方釋放資源）等問題。這使得測試和偵錯的過程變得更為複雜。需要使用專門的工具和技術來進行測試，例如使用多執行緒的偵錯工具，並仔細檢查同步和共享資源的管理。



### 使用者執行緒 vs. 核心執行緒

1. **使用者執行緒（User Threads）**：
   - **定義**：使用者執行緒是由應用程式在使用者空間中管理的執行緒。它們不需要直接與作業系統核心交互。
   - 特點：
     - 輕量級，創建和銷毀的開銷較小。
     - 上下文切換速度快，因為不涉及核心切換。
     - 由於作業系統不知道使用者執行緒的存在，因此無法進行有效的負載平衡和資源管理。
     - 如果一個使用者執行緒進入阻塞狀態，整個進程也會被阻塞，這會影響其他執行緒的執行。
2. **核心執行緒（Kernel Threads）**：
   - **定義**：核心執行緒由作業系統核心管理，能夠直接獲取處理器資源。
   - 特點：
     - 每個核心執行緒都由作業系統進行排程和管理。
     - 能夠利用多核處理器的並行處理能力，進行有效的負載平衡。
     - 一個核心執行緒的阻塞不會影響其他執行緒，允許更高的系統吞吐量。
     - 上下文切換相對較慢，因為涉及核心層面的操作。



### 多執行緒模式

在多執行緒環境中，執行緒的映射方式可以有三種主要模式：

#### 1. 多對一模式（Many-to-One Model）

- **定義**：在這種模式中，多個使用者執行緒映射到單個核心執行緒。
- 特點：
  - 使用者執行緒的管理完全在使用者空間進行。
  - 上下文切換快速，因為不需要進入核心。
  - 但如果任何一個使用者執行緒進入阻塞狀態，整個進程會被阻塞，無法利用其他執行緒。
- **例子**：某些早期的編程語言或庫，如Green Threads。

#### 2. 一對一模式（One-to-One Model）

- **定義**：在這種模式中，每個使用者執行緒都映射到一個核心執行緒。
- 特點：
  - 提供了更好的並行性，因為每個執行緒都可以獨立執行，且不會互相阻塞。
  - 作業系統能夠進行有效的排程和資源分配。
  - 上下文切換的開銷較高，因為涉及核心操作。
- **例子**：許多現代作業系統，如Linux和Windows，都採用一對一模型來實現執行緒管理。

#### 3. 多對多模式（Many-to-Many Model）

- **定義**：在這種模式中，許多使用者執行緒可以映射到較少或數量相等的核心執行緒。
- 特點：
  - 提供了最大的靈活性，允許使用者執行緒的數量不受核心數量的限制。
  - 可以根據需要動態地分配核心執行緒，使得資源利用率最優化。
  - 可以有效地處理阻塞情況，因為如果一個核心執行緒被阻塞，其他核心執行緒仍然可以執行其他使用者執行緒。
- **例子**：這種模式較為複雜，許多現代的作業系統或框架（如某些Java虛擬機）會使用多對多模型來支持並行性。