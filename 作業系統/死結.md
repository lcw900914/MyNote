# 死結

以下講義將循序漸進地介紹死結（Deadlock）的核心概念，並配合範例與解答，協助理解與應用。

------

## Part 1：死結基本觀念

在作業系統中，**死結（Deadlock）** 是指一組行程（Process）或執行緒（Thread），因相互競爭或佔用資源，最終導致彼此都無法繼續執行的狀態。簡單來說，大家都「卡住」了，沒有人能繼續前進。

### 為何要談死結？

- **系統穩定性**：若系統不斷產生死結，便會導致服務停頓或效能下降。
- **資源有效利用**：死結會造成行程一直占用資源但無法繼續執行，導致其他行程無法取得足夠資源。
- **管理與排除**：系統開發、管理與運維人員需要知道如何預防、偵測與處理死結問題。

------

## Part 2：死結的條件

在經典理論裡，死結有四大必要條件（有時簡化成三到四項互相包涵的條件），但是常見的教科書會提到以下「四大條件」必須同時成立，才會發生死結：

1. **互斥（Mutual Exclusion）**
   - 系統中至少有一個資源在同一時間只能被一個行程使用。
   - 例如：印表機、檔案寫入等，若同時給多個行程存取會產生問題。
2. **持有並等待（Hold and Wait）**
   - 行程已經持有至少一個資源，並且同時還在等待其他資源。
   - 例如：行程 A 先持有印表機，但還需要掃描器才可完成工作；掃描器卻被行程 B 使用，行程 A 就在等待行程 B 釋放掃描器。
3. **不可搶奪（No Preemption）**
   - 資源無法被強制搶奪，只能由行程自行釋放。
   - 例如：你無法直接把行程 B 正在使用的掃描器「搶」過來，只能等待它釋放。
4. **環路等待（Circular Wait）**
   - 存在一條環路序列：行程 A 等待行程 B 所持有的資源、行程 B 等待行程 C 所持有的資源、…… 最後又回到行程 A。
   - 形成一個「循環依賴」，沒有人能主動釋放資源。

> **注意**：在部分簡易課程或書籍中，有時會將「不可搶奪」視為「持有並等待」的延伸或將「環路等待」歸納到其他條件中，因此會看到「三大條件」的說法。無論三或四，基本概念都相通：只有同時具備這些條件，才會產生死結。

------

## Part 3：互斥為何重要？

有人會問：「為什麼要互斥？如果互斥是造成死結的條件之一，那我們乾脆不要互斥不就好？」

- **正面意義**：互斥其實是必要的，否則共用資源（例如記憶體、檔案、I/O 裝置）的數據可能被多個行程同時讀寫，導致結果錯亂。
- **必要之惡**：互斥確實會提高死結風險，但若沒有互斥機制，會帶來更糟糕的競爭條件（Race Condition）。

結論：互斥是保證資源被正確使用的機制，帶來了死結的風險，但也是系統可靠執行的基石。

------

## Part 4：偵測死結的演算法

當系統未事先避免或預防死結時，可能透過以下方式「偵測」死結是否發生：

1. **資源分配圖（Resource Allocation Graph）**
   - 資源分配圖由「行程節點」與「資源節點」兩種類型構成：
     - 行程節點：代表行程 Pi
     - 資源節點：代表資源 Rj
   - 資源分配圖中，若找到一條環路（Cycle），就代表可能有死結。
2. **Wait-for Graph（等待圖）**
   - 簡化資源分配圖，只保留「行程對行程」的等待關係。
   - 若在等待圖中找到一條環路，表示行程之間互相等待，出現死結。
3. **每隔一定時間檢查**
   - 作業系統可以週期性地執行「死結偵測演算法」，一旦偵測到死結，就可做後續的復原措施。

------

## Part 5：解決死結的演算法

### 1. 預防（Prevention）

想辦法「破壞」死結產生的必要條件，常見方法包括：

- **破壞持有並等待**：在行程開始前，就必須一次性申請到所有所需資源；若拿不到就不執行。
- **破壞不可搶奪**：系統允許資源可以被搶奪。
- **破壞環路等待**：對資源做全域性的順序排序（Order），行程只能按順序申請資源，避免形成環路。

### 2. 避免（Avoidance）

利用演算法（如 **銀行家演算法 Banker’s Algorithm**）動態計算「若允許此行程取得資源，系統是否會處於安全狀態（safe state）」。若判定無法保證安全，則拒絕資源申請。

- **銀行家演算法**：核心概念是模擬「若給定行程要求的資源後，剩餘資源是否能滿足其他行程的最大需求」，若不行就暫時不給資源，避免死結。

### 3. 偵測與復原（Detection & Recovery）

如果系統並未使用「預防」或「避免」策略，就要透過偵測演算法檢查是否發生死結。一旦發現死結，常用的復原措施：

1. **終止行程**
   - 強制中止某些行程，釋放資源。
   - 可能是一次中止所有死結中的行程，或中止一個行程再重新偵測。
2. **回收資源**
   - 若系統設計容許「搶奪」機制，就可從某些行程中回收資源，讓其他行程繼續。

------

## Part 6：如何修復死結

當你已經偵測到死結確實發生了，接下來能做的就是「復原」：

1. **結束行程**
   - 選擇代價最小的行程終止（例如佔用資源多的行程、或優先權較低的行程）。
   - 終止後，釋放它所持有的資源給其他行程使用。
2. **回到安全狀態**
   - 配合死結偵測演算法，找出最小的中止集合（Minimal Set of Processes），停止最少數的行程就可解除死結。
3. **重新啟動**
   - 被強制停止的行程要透過某種機制重新啟動或重跑，以免影響整體工作流程。

------

## 範例題與解答

### 範例題 1

系統中有兩個行程 P1 與 P2，以及兩個資源 R1 與 R2。

- 初始狀態：
  - P1 已持有 R1，等待 R2。
  - P2 已持有 R2，等待 R1。
- 問題：
  1. 請問這是否構成死結？
  2. 符合哪幾個條件？

**解答**

1. 是否構成死結？
   - 是。因為 P1 在等待 P2 持有的資源 R2，同時 P2 也在等待 P1 持有的資源 R1。兩者相互等待，無法進一步執行。
2. 符合條件
   - **互斥**：R1,R2 都是一次只能被一個行程使用。
   - **持有並等待**：P1 和 P2 都已持有部分資源，並等待其他資源。
   - **不可搶奪**：行程無法直接把對方的資源搶過來。
   - **環路等待**：存在一個循環等待的關係 P1→R2→P2→R1→P1

### 範例題 2

假設有三個行程 PA,PB,PC，以及四個相同類型的資源（如同四台機器），每個行程最少需要兩個資源才能完成工作。現在系統狀態如下：

- PA 已持有 1 個資源，但尚需 1 個才能執行完畢。
- PB 已持有 1 個資源，但尚需 1 個才能執行完畢。
- PC 已持有 1 個資源，但尚需 1 個才能執行完畢。
- 系統剩餘的可用資源還有 1 個。

請問：若此時又有一個行程（如 PA）提出「再申請一個資源」的要求，該如何判斷是否會導致死結？

**解答**

- 可以運用**銀行家演算法**（Banker’s Algorithm）來做判斷：
  1. 若把剩下的 1 個資源分配給 PA，系統就沒有多餘資源了。
  2. 之後 PB 與 PC 各需要 1 個資源才可完成，但系統已無可用資源。
  3. 若 PA 用完資源能馬上釋放，那就不會死結。若 PA 無法立刻完成或釋放，則 PB 和 PC 也無法前進，可能陷入死結。
- 實際操作時，系統要**模擬資源分配**之後能否使每個行程在理想情況下完成。若有一個行程無法被滿足，就可能導致死結狀態。

------

## 結語

在作業系統中，死結是不可忽視的議題。了解死結如何產生（四大必要條件）以及如何透過預防、避免與偵測復原機制來對抗死結，是每位系統程式設計師與管理員必須具備的知識技能。只要理解這些概念，並在設計系統時謹慎思考，便能大幅降低死結的發生機率，進而提升系統的穩定度與效率。

------

### 重點總結

1. **死結條件**：互斥、持有並等待、不可搶奪、環路等待。
2. **為何要互斥**：保障資源正確使用，雖然增加死結風險，卻是必需。
3. **偵測方式**：資源分配圖、等待圖，週期性檢查。
4. 解決方法：
   - **預防（Prevention）**：破壞死結條件之一。
   - **避免（Avoidance）**：銀行家演算法確保系統不會進入不安全狀態。
   - **偵測與復原（Detection & Recovery）**：偵測到死結後，強制中止或回收資源。
5. **如何修復**：終止行程或回收資源，回到安全狀態。

